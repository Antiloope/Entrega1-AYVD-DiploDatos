# -*- coding: utf-8 -*-
"""Reporte[Borrador].ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_Es0-pdgxNtdmGHTQZeVT5lP4FOoyEJk
"""

import io
import matplotlib
import matplotlib.pyplot as plt
import numpy
import pandas as pd
import seaborn

seaborn.set_context("talk")

"""**Diplomatura en Ciencia de Datos, Aprendizaje Automático y sus Aplicaciones**

**Edición 2022**

---
# Trabajo práctico entregable - Parte 1

El objetivo del presente reporte es desarrollar un análisis de los resultados obtenidos en la Encuesta de Salarios 2020 realizado por Sysarmy. En particular, el siguiente análsis se centrará en intentar responder la pregunta **¿Cuáles son los lenguajes de programación asociados a los mejores salarios?**

A su vez, a los fines de lograr la reproductibilidad de las conclusiones, se detallarán los pasos seguidos para el procesamiento de los datos contenidos en la Encuesta, junto con las líneas de código utilizadas en cada instancia.

### 1) Selección de columnas  

En primer lugar, seleccionaremos las columnas sobre las cuales centraremos el análisis. En ese sentido, consideramos que las columnas más relevantes para ello son las siguientes:  

*   "Tool Programing Languaje" 
*   "Salary Monthly NETO"  

**NOTA:** En relación al dato sobre el monto salarial indicado por cada participante de la encuesta, optamos por elegir aquella columna que contempla el importe neto mensual ya que entendemos que los datos contemplados en ella son los que mejor expresan la ganancia efectiva de bolsillo. Y éste sería el monto más "depurado" para luego determinar cuáles pueden ser considerados como los "mejores salarios"
"""

# En esta linea de código cargamos y leemos el dataset de la Encuensta 2020
url = "https://cs.famaf.unc.edu.ar/~mteruel/datasets/diplodatos/sysarmy_survey_2020_processed.csv"
df = pd.read_csv(url)

# Luego visualizamos la primeras columnas para verificar que se haya cargado bien
df[:3]

# Del dataframe "df", almacenamos en una variable las columnas que consideramos más relevantas
relevant_columns = ["tools_programming_languages", "salary_monthly_NETO"]

"""### 2) Selección de Filas  

Una vez determinadas las columnas donde están expresados los dato más relevantes para nuestro análisis, el paso siguiente es filtrar aquellas filas o registros que puedan contener valores extremos o datos erróneos.  

Para ello, como paso previo, optamos por realizar algunas visualizaciones previas de los datos con el objetivo de tener una primer aproximación sobre cómo están distribuidos, y un breve resumen de algunas métricas básicas que nos permitan lograr un entendimiento rápido de lo que se encuentra en el dataset.  

Con ese fin, generamos un Histograma de distribución de los valores contemplados en la columna de salario neto mensual. Y mediante el método "describe()" de Pandas, visualizamos algunas métricas descripitvas para disponer de algunos números que permitan orientar la definición de los criterios para el filtrado de las filas que puedan estar generando algún "ruido" en el análisis.
"""

# Con esta línea generamos un resumen de algunas métricas descriptivas de los datos contenidos
# en la columna "salary_monthly_NETO"
df["salary_monthly_NETO"].describe().apply(lambda s: "{0:.2f}".format(s))

# Posteriormente, generamos un Histograma para tener una visualización de aquellos mismos datos
seaborn.displot(
    df.salary_monthly_NETO[df.salary_monthly_NETO < 2000000].dropna(),
    stat="count",
    aspect=4,
)
plt.ticklabel_format(style="plain", axis="x")

"""Luego de una primer visualización de los datos "en bruto", procedemos a aplicar algunos criterios con el fin de eliminar valores extremos o erróneos.  

**- Descartar valores extremos:**  
* En este caso, optamos por descartar aquellos registros donde el monto salarial indicado sea inferior al monto del Salario Minimo Vital para 2020 (unos $20000 aproximadamente). Esto en razón de que la consigna apunta a trabajar con los "mejores salarios", y en ese sentido acordamos que al menos para entrar en dicha categoría un salario debería superar el monto minimo a abonar por cualquier trabajo para el período analizado.  

* Además, descartamos aquellos registros en los cuales se indicó un importe igual a *cero*, ya que entendemos que pueden deberse a un error a la hora de completar la encuesta y por ende no aporta al análisis perseguido en este reporte.  

* Por otra parte, tampoco consideraremos aquellos registros cuyo monto sea superior a $1000000. Ello debido a que, de la primer visualización generada en la instancia previa, se puede ver que el grueso de los importes se concentran en valores menores al millón, por lo que aquellos valores que lo superen podrían ser entendidos como outliers que pueden generar algún "ruido" al analizar los datos.  

**- Descartar valores erróneos**  
* Si bien la respuesta "Ninguno" en el campo sobre lengujaes de programación que se concen no es de por sí un dato erróneo, a los fines de la consigna planteada que apunta a identificar los lenguajes de programación asociados a los mejores salarios, dicha respuesta no aportaría a este análisis. Por dicho motivo, también optamos por filtrar aquellos registros que contengan la respuesta "Ninguno".
"""

# Aplicamos los filtros de valores extremos en la columna de salario, y
# del valor "Ninguno" en la columna de lenguajes
filter = df[df["salary_monthly_NETO"] > 20000]
filter = filter[filter["salary_monthly_NETO"] < 1000000]
filter = filter[filter["tools_programming_languages"] != "Ninguno"]
# len(filter)

# Visualizamos nuevamente los datos, para ver como queda la distribución
# luego de aplicados los filtros respectivos
seaborn.displot(filter.salary_monthly_NETO.dropna(), stat="count", aspect=3)
plt.ticklabel_format(style="plain", axis="x")

"""Luego procedemos a visualizar aquel stack de lenguajes que más se repite, a los fines de fijar cuáles se tomarán para este análisis.  

Optamos por analizar stack de lenguajes, en lugar de lenguajes individuales ya que consideramos que tiene más sentido ver la combinación de lenguajes que forman un "stack" a los fines de definir aquellos que se asocien con los mejores salarios.
"""

# Convert the comma-separated string of languages to a list of string.
# Remove 'ninguno de los anteriores' option, spaces and training commas.
def split_languages(languages_str):
    if not isinstance(languages_str, str):
        return []
    # Remove 'other' option
    languages_str = languages_str.lower().replace("ninguno de los anteriores", "")
    # Split string into list of items
    # Remove spaces and commas for each item
    return [lang.strip().replace(",", "") for lang in languages_str.split()]


# Crear una columna nueva con la lista de lenguajes en lugar de un string
filter.loc[:, "cured_programming_languages"] = filter.tools_programming_languages.apply(
    split_languages
)
if "cured_programming_languages" not in relevant_columns:
    relevant_columns.append("cured_programming_languages")

# En esta línea se realiza un count de los stacks de lenguajes contemplados, y luego
# se guardan los 10 grupos que más se repiten
language_count = (
    filter.cured_programming_languages.value_counts()
    .reset_index()
    .rename(columns={"index": "language", "cured_programming_languages": "frequency"})
)
freq_list = language_count["language"][:11].to_list()
freq_list = [x for x in freq_list if x]
# language_count[:11]
freq_list

"""Una vez obtenidos los stacks que más se reiteran, visualizamos aquellos registros en donde están presentes algunos de esos grupos de lenguajes."""

# Filtramos para quedaron con los registros que tengan alguno de lo stacks de lenguajes
# de la lista "freq_list"
filter_top = filter[filter["cured_programming_languages"].isin(freq_list)].reset_index()

# transformamos en string la columna programming_languages para poder visualizar esos datos en el próximo gráfico
def volver_string(languages_str):
    return str(languages_str)


filter_top.loc[
    :, "programming_language"
] = filter_top.cured_programming_languages.apply(volver_string)

filter_top.loc[:, ["programming_language", "cured_programming_languages"]]

# generamos un gráfico de cajas para ver algunas métricas en relación l top 10 de los stacks de lenguajes
# filtrados anteriormente
plt.figure(figsize=(12, 6))
seaborn.boxplot(
    data=filter_top,
    x="salary_monthly_NETO",
    y="programming_language",
    color="orangered",
)
plt.ticklabel_format(style="plain", axis="x")

# generamos otra visualización de la información de los stacks
fig = plt.figure(figsize=(15, 11))
seaborn.countplot(y=filter_top.programming_language, color="steelblue")

# aplicamos el método "describe()" para ver nuevamente de forma sintética
# un resumen de las métricas principales luego de haber aplicado los respectivos filtros
filter_top.salary_monthly_NETO.describe()

"""### 3)Selección de métricas



* **Probabilidad Condicional**: ¿Cuál es la probabilidad de cobrar más que el promedio, dado que se maneja un stack de lenguajes de programación de front-end [css+html+js]?

Previo a calcular la probabilidad condicional planteada, calculamos la probabilidad de cobrar más que el promedio
"""

# Guardamos en una variable el valor del salario promedio
avg_salary = filter_top.salary_monthly_NETO.mean()

# En esta línea calculamos la probabilidad de cobrar por arriba del salario promedio
prob_above_avg = len(filter_top[filter_top["salary_monthly_NETO"] >= avg_salary]) / len(
    filter_top
)
print(prob_above_avg)

"""Luego procedemos a calcular la probabilidad condicional de cobrar más que el salario promedio, si dentro del stack de lenguajes manejados por un/a programador/a se contemplan aquellos vinculados al desarrrollo de front-end"""

# En esta línea filtramos aquellos registros donde el salario mensual neto es mayor al salario promedio
is_above_avg = filter_top["salary_monthly_NETO"] > avg_salary

# Con esta línea filtramos aquellos registros donde en la columna programming_lenguages
# contengan los tres lenguajes más comúnmente asociados al desarrollo front-end (css,html,javascript)
front_end_stack = filter_top.query(
    'programming_language.str.contains("javascript") and programming_language.str.contains("html") and programming_language.str.contains("css")',
    engine="python",
)

# En esta línea obtenemos la intersección entre las dos variables definidas arriba
intersection_count = len(
    filter_top.query(
        'programming_language.str.contains("javascript") and programming_language.str.contains("html") and programming_language.str.contains("css") and salary_monthly_NETO > salary_monthly_NETO.mean()',
        engine="python",
    )
)

# Calculamos la probabilidad condicional y comparamos con la probabilidad marginal calculada previamente
p_condic_above_avg = intersection_count / len(front_end_stack)
print(
    f"Probabilidad de ganar más del salario promedio manejando un stack fronte-end: {p_condic_above_avg}"
)
print(f"Probabilidad de ganar por encima del salario promedio: {prob_above_avg}")

"""De los datos puede deducirse que si una persona maneja un stack "front-end" de programación, tiene una probabilidad del 30% de ganar un monto por arriba del salario mensual promedio. Sin embargo, si se lo compara contra la probabilidad marginal de ganar por encima del salario mensual (37%) se puede concluir que manejar un stack "front-end" solamente, no da buenas chances de estar en el rango de los mejores salarios.

Podemos analizar también cual es el procentaje de probabilidad de ganar por arriba del salario neto promedio, si en el stack que un profesional del software maneja se encunentran lenguajes asociados al análisis y manejo de datos, como python y sql
"""

# con esta línea nos quedamos con lo registros que contengan sql o python en su stack
sql_stack = filter_top.query(
    'programming_language.str.contains("sql")', engine="python"
)
python_stack = filter_top.query(
    'programming_language.str.contains("python")', engine="python"
)

# en estas líneas calculamos la intrsección entre aquellos registros que tienen en su stack de lenguajes
# python o sql y el salairo es mayor al monto promedio
intersection_sql = len(
    filter_top.query(
        'programming_language.str.contains("sql") and salary_monthly_NETO > salary_monthly_NETO.mean()',
        engine="python",
    )
)
intersection_python = len(
    filter_top.query(
        'programming_language.str.contains("python") and salary_monthly_NETO > salary_monthly_NETO.mean()',
        engine="python",
    )
)

p_condic_above_avg_sql = intersection_sql / len(sql_stack)
p_condic_above_avg_sql

p_condic_above_avg_python = intersection_python / len(python_stack)
p_condic_above_avg_python

"""De los resultados obtenidos arrbia, se puede concluir que conocer solo sql no supone una mejora en la probabilidad de ganar más del salario promedio, en relación al porcentaje obtenido para aquellos programadores que poseen un stacks "front-end".
Por otra parte, el manejo de python si sopone una mejor situación, ya que la probabilidad de ganar por encima del salario promedio, que es del 45%, es superior a la probabilidad marginal (37%)
"""
